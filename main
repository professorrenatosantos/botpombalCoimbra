#include <BnrOneA.h>   
#include <EEPROM.h>    
#include <SPI.h>       

BnrOneA one;  // Bot'n Roll ONE A object

// Constants
#define SSPIN  2    
#define M1  1       
#define M2  2       
#define Vtrans 500  // Lower threshold for better sensitivity
#define BAT_MIN 10.5 // Battery protection
#define BASE_SPEED 25 // Reduce base speed slightly
#define TURN_SPEED 25 // Reduce turning speed
#define SHARP_TURN_SPEED 65 // Reduce sharp turns

// Adjusted Weights (Boost Left Sensitivity)
float weights[8] = {1.5, 1.3, 1.2, 1.0, 1.0, 1.2, 1.3, 1.5}; 

// Global variable to track last detected sensor
int lastDetectedSensor = 3; // Assume the center at start
int branco = 900;

void setup() {  
    Serial.begin(57600);     
    one.spiConnect(SSPIN);  
    one.stop();              
    one.minBat(BAT_MIN);
    one.lcd1(" Bot'n Roll ONE");

    while(one.readButton() == 0) {
        one.lcd2("Press a button!");
        delay(50);
    }
    one.move(BASE_SPEED, BASE_SPEED);
    one.lcd2("Line Following!");	
}

// Function to read sensors and apply weights
void readSensors(int sensor[]) {
    for(int i = 0; i < 8; i++) {
        sensor[i] = one.readAdc(i) * weights[i];
    }
}

// Function to determine movement based on sensor readings
void followLine() {
    int sensor[8];
    readSensors(sensor);

    int maxSensor = -1;
    int maxValue = branco; //Vtrans; // Start with threshold value

    // Find the sensor with the highest reading
    for (int i = 0; i < 8; i++) {
        if (sensor[i] < maxValue) {
            maxValue = sensor[i];
            maxSensor = i;
        }
    }

    Serial.print("Detected Sensor: ");
    Serial.println(maxSensor);

    int leftSpeed = BASE_SPEED;
    int rightSpeed = BASE_SPEED;

    if (maxSensor != -1) { 
        lastDetectedSensor = maxSensor; // Store last valid detection
    }

    switch (maxSensor) {
        case 0:  // Gentle left turn
            leftSpeed = -BASE_SPEED; 
            rightSpeed = BASE_SPEED;
            break;
        case 1:  // Smooth left turn
            leftSpeed = BASE_SPEED - 10; 
            rightSpeed = BASE_SPEED + 10;
            break;
        case 2:  // Slight left turn
            leftSpeed = BASE_SPEED - 5;
            rightSpeed = BASE_SPEED + 5;
            break;
        case 3:  
        case 4:  // Go straight
            leftSpeed = BASE_SPEED;
            rightSpeed = BASE_SPEED;
            break;
        case 5:  // Slight right turn
            leftSpeed = BASE_SPEED + 5;
            rightSpeed = BASE_SPEED - 5;
            break;
        case 6:  // Smooth right turn
            leftSpeed = BASE_SPEED + 10;
            rightSpeed = BASE_SPEED - 10;
            break;
        case 7:  // Gentle right turn
            leftSpeed = BASE_SPEED;
            rightSpeed = -BASE_SPEED;
            break;
        default:  // Line lost - Adjust recovery
            if (lastDetectedSensor <= 3) { // If last seen on left
                leftSpeed = -TURN_SPEED + 10; // Reduce sharpness
                rightSpeed = TURN_SPEED;
            } else { // If last seen on right
                leftSpeed = TURN_SPEED;
                rightSpeed = -TURN_SPEED + 10;
            }
            break;
    }

    Serial.print("Motor Speeds - Left: ");
    Serial.print(leftSpeed);
    Serial.print(" Right: ");
    Serial.println(rightSpeed);

    one.move(leftSpeed, rightSpeed);
}

void loop() {
    followLine();
    while(one.readButton() == 1) {
        branco = branco - 2;
        one.lcd2("branco = " , branco);
        delay(50);
    }
    while(one.readButton() == 2) {
        branco = branco + 2;
        one.lcd2("branco = " , branco);
        delay(50);
    }
}

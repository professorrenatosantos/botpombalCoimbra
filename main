#include <BotNRoll.h>
#include <Servo.h>
#include "pitches.h"
  
// TESTE
//  Distância mínima para considerar parede (em cm)

// notes in the melody:
int melody[] = {NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4};

// note durations: 4 = quarter note, 8 = eighth note, etc.:
int noteDurations[] = {4, 8, 8, 4, 4, 4, 4, 4};

BotNRoll robot;

// ############################ SegueParede############################################
const uint16_t DISTANCIA_PAREDE = 300;
const uint16_t DISTANCIA_PAREDE_FRENTE = 300;
const uint16_t IDEAL_MIN = 80;
const uint16_t IDEAL_MAX = 120;
bool flagSeguelinha = false;
bool flagEsqueda = true;
bool flagEncomenda = false;

// ############################ SegueLinha ############################################
#define SSPIN  2     
#define Vtrans 500          // Lower threshold for better sensitivity
#define BAT_MIN 10.5        // Battery protection
#define BASE_SPEED 20       // Reduce base speed slightly
#define TURN_SPEED 15       // Reduce turning speed
#define SHARP_TURN_SPEED 65 // Reduce sharp turns
#define VELOCIDADE 0.5
float Kp = 10.0;

// Adjusted Weights (Boost Left Sensitivity)
float weights[8] = {1.5, 1.3, 1.2, 1.0, 1.0, 1.2, 1.3, 1.5};
// Global variable to track last detected sensor
int lastDetectedSensor = 3; // Assume the center at start
int preto = 300;
int branco = 150;

static unsigned long tempoEntradaSala = 0;

// Function to read sensors and apply weights
void readSensors(int sensor[])
{
    for (int i = 0; i < 8; i++)
    {
        //sensor[i] = robot.readAdc(i) * weights[i];
        sensor[i] = robot.readAdc(i);
    }
}

// Function to determine movement based on sensor readings
bool verificaLinhaSala(int nbrancos)
{
    int sensors[8];
    int nSensoresBranco = 0;
    Serial.println("Função Verifica Linhas:");

    for (int i = 0; i < 8; i++)
    {
        sensors[i] = robot.readAdc(i);
        if (sensors[i] < branco)
        {
            Serial.println(sensors[i]);
            nSensoresBranco = nSensoresBranco + 1;
        }
    }

    // // Print sensor values to serial monitor.
    // Serial.println("LINE SENSOR VALUES:");
    // for (int i = 0; i < 8; i++)
    // {
    //     Serial.print(String(sensors[i]) + ", ");
    // }
    // Serial.println();

    
    Serial.print("Sensores Branco = ");
    Serial.println(nSensoresBranco);

    if (nSensoresBranco > nbrancos)
    {
        Serial.print("TRUE Sensores Branco = ");
        Serial.println(nSensoresBranco);
        return true;
    }

    else
    {
        Serial.print("FALSE Sensores Branco = ");
        Serial.println(nSensoresBranco);
        return false;
    }
}



int followLine(){

    int sensors[8];
    int nSensoresBranco=0;

    for (int i = 0; i < 8; i++) {
        sensors[i] = robot.readAdc(i);
    }

    if (sensors[7] <= branco)
    {
        robot.move(40 * VELOCIDADE, -20 * VELOCIDADE);
    }

    if (sensors[6]  <= branco)
    {
        robot.move(40 * VELOCIDADE, -5 * VELOCIDADE);
    }

    if (sensors[5]  <= branco)
    {
        robot.move(40 * VELOCIDADE, 7 * VELOCIDADE);
    }

    if (sensors[4]  && sensors[3] <= branco)
    {
        robot.move(30 * VELOCIDADE, 30 * VELOCIDADE);
    } 

    if (sensors[2]  <= branco)
    {
        robot.move(7 * VELOCIDADE, 40 * VELOCIDADE);
    } 

    if (sensors[1]  <= branco)
    {
        robot.move(-5 * VELOCIDADE, 40 * VELOCIDADE);
    } 

    if (sensors[0]  <= branco)
    {
        robot.move(-20 * VELOCIDADE, 40 * VELOCIDADE);
    }  

    for (int i = 0; i < 8; i++)
    {
        if (sensors[i] < branco)
        {
            nSensoresBranco = nSensoresBranco + 1;
        }
    }
    return nSensoresBranco;

    // int nSensoresBranco = 0;

    // Serial.print("Sensores Branco = ");
    // Serial.println(nSensoresBranco);
    // // Find the sensor with the highest reading
    // for (int i = 0; i < 8; i++)
    // {
    //     if (sensors[i] < branco)
    //     {
    //         Serial.println(sensors[i]);
    //         nSensoresBranco = nSensoresBranco + 1;
    //     }
    // }
    // Serial.print("Sensores Branco = ");
    // Serial.println(nSensoresBranco);

    // if (nSensoresBranco > 4)
    // {
    //     Serial.print("TRUE Sensores Branco = ");
    //     Serial.println(nSensoresBranco);
    //     tone(9, 200, 200);
    //     return true;
    // }

    // else
    // {
    //     Serial.print("FALSE Sensores Branco = ");
    //     Serial.println(nSensoresBranco);
    //     return false;
    // }
}

void encontrarParedeEsquerda(){
    uint16_t left = robot.getLidarLeftDistance();
    Serial.print("L: ");
    Serial.print(left);

    while (left>DISTANCIA_PAREDE)
    {
        robot.move(-30,30);
        left = robot.getLidarLeftDistance();    
    }
    robot.move(30,30);
}




// TESTE
/* The setup function runs once when you press reset or power the board */
void setup()
{
    // Set baud rate to 9600bps for printing values on the serial monitor.
    Serial.begin(9600);
    Serial.println("BOIIIIIIIIII:");

    // Initialize the robot.
    robot.begin();

    // Wait for button (PB1) to be pressed.
    while (robot.readButton() != 1)
    {

        // Set servo position to 0.
        robot.servo1(0);

        // Get distances from the laser sensors on the front of the robot.
        uint16_t left = robot.getLidarLeftDistance();
        uint16_t front = robot.getLidarFrontDistance();
        uint16_t right = robot.getLidarRightDistance();

        // Print distance values to serial monitor.
        Serial.println("LIDAR VALUES:");
        Serial.println("Left: " + String(left) + "mm");
        Serial.println("Front: " + String(front) + "mm");
        Serial.println("Right: " + String(right) + "mm");

        // Get brightness values from the line sensor array on the bottom of the robot.
        int sensors[8];
        for (int i = 0; i < 8; i++)
        {
            sensors[i] = robot.readAdc(i);
        }

        // Print sensor values to serial monitor.
        Serial.println("LINE SENSOR VALUES:");
        for (int i = 0; i < 8; i++)
        {
            Serial.print(String(sensors[i]) + ", ");
        }
        Serial.println();

        // Print LDR value to serial monitor.
        Serial.println("LDR SENSOR VALUE:");
        Serial.print(robot.getLDRValue());
        Serial.println();

        delay(2000);
    }
    
    encontrarParedeEsquerda();

}

void segueParedeEsquerda(){
    

    uint16_t left = robot.getLidarLeftDistance();
    uint16_t front = robot.getLidarFrontDistance();
    uint16_t right = robot.getLidarRightDistance();

    Serial.print("L: ");
    Serial.print(left);
    Serial.print(" | F: ");
    Serial.print(front);
    Serial.print(" | R: ");
    Serial.println(right);

    // PRIORIDADE 1: Virar à esquerda se NÃO houver parede à esquerda
    if (left > DISTANCIA_PAREDE)
    {
        robot.move(2, 40);
        Serial.println("Virar à esquerda (sem parede à esquerda)");

        if (verificaLinhaSala(1))
        {
            robot.move(10,10);
            tempoEntradaSala = millis();
            flagSeguelinha = true;
            Serial.println("segue linha: true");
            if (flagSeguelinha)
            {
                //robot.stop();
                //tone(9, 1000, 200);
                robot.lcd1("SEGUE LINHA TRUE");
                //robot.move(BASE_SPEED, BASE_SPEED);
                Serial.println("segue linha: true");
                // robot.move(BASE_SPEED, BASE_SPEED);
                while (flagSeguelinha)
                {
                    //robot.lcd1("SEGUE LINHA WHILE");
                    Serial.println("segue linha: ciclo infinito");
                    int n = followLine();
                    Serial.println(n);
                    //delay(1000);
                    //if(verificaLinhaSala(3) && millis() - tempoEntradaSala >= 4000){
                    if(n>3 && millis() - tempoEntradaSala >= 5000){
                        flagEsqueda=false;
                        robot.lcd1("SEGUE LINHA SAI SALA");
                        //tone(9, 1500, 200);
                        delay(700);
                        flagEncomenda=true;
                        break;
                    }
                }
            }
        }
    }
    // PRIORIDADE 2: Virar à direita se HÁ parede à frente E à esquerda
    else if (front < DISTANCIA_PAREDE_FRENTE && left < DISTANCIA_PAREDE)
    {
        robot.move(60, -10); // curva acentuada à direita
        Serial.println("Virar à direita (parede à frente e à esquerda)");
    }
    // PRIORIDADE 3: Ajustar distância à parede da esquerda
    else
    {
        if (left < IDEAL_MIN)
        {
            robot.move(35, 10);
            Serial.println("Afastar da parede à esquerda");
        }
        else if (left > IDEAL_MAX)
        {
            robot.move(10, 35);
            Serial.println("Aproximar da parede à esquerda");
        }
        else
        {
            robot.move(35, 35);
            Serial.println("Distância ideal — seguir em frente");
        }
    }
}


void segueParedeDireita(){
    
    uint16_t left = robot.getLidarLeftDistance();
    uint16_t front = robot.getLidarFrontDistance();
    uint16_t right = robot.getLidarRightDistance();

    Serial.print("L: ");
    Serial.print(left);
    Serial.print(" | F: ");
    Serial.print(front);
    Serial.print(" | R: ");
    Serial.println(right);

    // PRIORIDADE 1: Virar à direita se NÃO houver parede à direita
    if (right > DISTANCIA_PAREDE)
    {
        robot.move(65, 1);
        Serial.println("Virar à direita (sem parede à direita)");
        if (verificaLinhaSala(1))
        {
            robot.move(10,10);
            tempoEntradaSala = millis();
            flagSeguelinha = true;
            Serial.println("segue linha: true");
            if (flagSeguelinha)
            {
                uint16_t front = robot.getLidarFrontDistance();
                //robot.stop();
                //tone(9, 1000, 200);
                robot.lcd1("SEGUE LINHA TRUE");
                //robot.move(BASE_SPEED, BASE_SPEED);
                Serial.println("segue linha: true");
                // robot.move(BASE_SPEED, BASE_SPEED);
                while (flagSeguelinha)
                {
                    front = robot.getLidarFrontDistance();
                    //robot.lcd1("SEGUE LINHA WHILE");
                    Serial.println("segue linha: ciclo infinito");
                    int n = followLine();
                    Serial.println(n);
                    //delay(1000);
                    //if(verificaLinhaSala(3) && millis() - tempoEntradaSala >= 4000){
                    if(front<DISTANCIA_PAREDE && millis() - tempoEntradaSala >= 4000 && flagEncomenda){
                        robot.stop();
                        tone(9, 1500, 1000);
                        delay(400);
                        tone(9, 1500, 1000);
                        robot.move(-30,-30);
                        delay(200);
                        while (robot.readAdc(3)<branco || robot.readAdc(4)<branco)
                        {
                            robot.move(-15,15);
                        }
                        while (robot.readAdc(3)>branco || robot.readAdc(4)>branco)
                        {
                            robot.move(-15,15);
                        }
                        
                        flagEncomenda=false;
                    }

                    if(n>3 && flagEncomenda==false){
                        flagEsqueda=false;
                        robot.lcd1("SEGUE LINHA SAI SALA");
                        //tone(9, 1500, 200);
                        delay(1500);
                        break;
                    }

                }
            }
        }
    }
    // PRIORIDADE 2: Virar à direita se HÁ parede à frente E à esquerda
    else if (front < DISTANCIA_PAREDE_FRENTE && right < DISTANCIA_PAREDE)
    {
        robot.move(-10, 60); // curva acentuada à esqueda
        Serial.println("Virar à esquerda (parede à frente e à direita)");
    }
    // PRIORIDADE 3: Ajustar distância à parede da esquerda
    else
    {
        if (right < IDEAL_MIN)
        {
            robot.move(10, 35);
            Serial.println("Afastar da parede à Direita");
        }
        else if (right > IDEAL_MAX)
        {
            robot.move(35, 10);
            Serial.println("Aproximar da parede à Direita");
        }
        else
        {
            robot.move(35, 35);
            Serial.println("Distância ideal — seguir em frente");
        }
    }
}

void segueParedeEsquerdaFinal(){
    

    uint16_t left = robot.getLidarLeftDistance();
    uint16_t front = robot.getLidarFrontDistance();
    uint16_t right = robot.getLidarRightDistance();

    Serial.print("L: ");
    Serial.print(left);
    Serial.print(" | F: ");
    Serial.print(front);
    Serial.print(" | R: ");
    Serial.println(right);


    if (verificaLinhaSala(1))
    {
        robot.move(10,10);
        delay(1500);
        robot.stop();
        
    }

    // PRIORIDADE 1: Virar à esquerda se NÃO houver parede à esquerda
    if (left > DISTANCIA_PAREDE)
    {
        robot.move(2, 40);
        Serial.println("Virar à esquerda (sem parede à esquerda)");

       
    }
    // PRIORIDADE 2: Virar à direita se HÁ parede à frente E à esquerda
    else if (front < DISTANCIA_PAREDE_FRENTE && left < DISTANCIA_PAREDE)
    {
        robot.move(60, -10); // curva acentuada à direita
        Serial.println("Virar à direita (parede à frente e à esquerda)");
    }
    // PRIORIDADE 3: Ajustar distância à parede da esquerda
    else
    {
        if (left < IDEAL_MIN)
        {
            robot.move(35, 10);
            Serial.println("Afastar da parede à esquerda");
        }
        else if (left > IDEAL_MAX)
        {
            robot.move(10, 35);
            Serial.println("Aproximar da parede à esquerda");
        }
        else
        {
            robot.move(35, 35);
            Serial.println("Distância ideal — seguir em frente");
        }
    }
}

// TESTE
/* The setup function runs once when you press reset or power the board */
void loop()
{
    //followLine();
    //segueParedeDireita();

    if (flagEsqueda)
        segueParedeEsquerda();
    else if(flagEncomenda && flagEsqueda==false){
        //tone(9, 100, 300);
        // tone(9, 200, 300);
        // tone(9, 300, 300);
        // tone(9, 400, 300);
        segueParedeDireita();
    }
    else{
        segueParedeEsquerdaFinal();
    }

}
